# What are the Adat functions

Adat classes provide a rich set of functions that go beyond standard Kotlin data classes. These include:

- Shallow copying with field overrides
- Structural diffing for comparison
- Dynamic property access via names or indexes
- Access to embedded class metadata
- Array-based serialization and instance reconstruction

These capabilities are generated by the Adaptive compiler and are essential for reactive applications,
metadata-driven UI, and schema-free transport layers.

## Shallow Copy

Create a shallow copy or a modified version:

```kotlin
val original = ExampleData(12, false)

val copy1 = original.copy()
val copy2 = original.copy(exampleInt = 23)
```

The `copy()` function works similarly to Kotlinâ€™s data class copy, allowing field overrides.

## Deep Copy

Create a deep copy:

```kotlin
val original = ExampleData(12, false)

val copy1 = original.deepCopy()
val copy2 = original.deepCopy(AdatChange(listOf("exampleInt"), 23))
```

The `deepCopy()` function creates a deep copy of the given adat instance, optionally it changes a property
during the copy operation.

The copy is independent of the original, any changes made on it will not change the original.

There are a few issues with deep copy to pay attention to:

* polymorphic properties are copied as-is (so there is no guarantee that they are independent)
* mutable collections are not supported yet (an exception is thrown), see: [Adat problems and improvements #35](https://github.com/spxbhuhb/adaptive/issues/35)

## Diff Between Instances

Compare two Adat instances and detect differences:

```kotlin
val original = ExampleData(12, false)
val copy = original.copy(exampleInt = 23)

val diff = original.diff(copy)
```

The `diff()` function returns a list of `AdatDiffItem` entries showing property-level changes.
Differences can include values, indexes, signatures, and missing fields.

## Setting Values by Name or Index

Modify values dynamically:

```kotlin
copy1.setValue(1, false)               // by index
copy1.setValue("exampleBoolean", true) // by name
```

Use `setValue()` to change mutable properties via reflection-like APIs. Setting immutable properties throws an exception.

## Getting Values by Name or Index

Access property values dynamically:

```kotlin
val value1 = copy1.getValue(0)
val value2 = copy1.getValue("exampleInt")

check(value1 == 12)
check(value2 == 12)
```

This supports use cases like schema-driven forms or table rendering.

## Accessing Metadata

Retrieve metadata for descriptors, validation, or reflection:

```kotlin
val metadataFromCompanion = ExampleData.adatMetadata
val metadataFromInstance = original.getMetadata()
```

Metadata includes structural descriptors and constraints encoded in JSON. It's usable for rendering forms, validating inputs, or creating schema exports.

## Converting to and from Arrays

Round-trip conversion between structured instances and arrays:

```kotlin
val arrayOfPropertyValues = original.toArray()
val copy = ExampleData.newInstance(arrayOfPropertyValues)
```

Useful for serialization and dynamic reconstruction, especially when type information is not known statically.